<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="1317" />
    <option name="newTranslationDialogY" value="136" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="This optimization also works if the key presents as a struct or array composite literal form: `T1{... Tn{..., string(key), ...} ...}`, where `Tx` is either a struct type or an array type. For example, the conversion `string(key)` in the following code doesn't do duplications, too." />
      <item value="Note: this optimization is not made for map element modification statements. This could be proved by the following example, in which the conversion `string(key)` in the `get` function doesn't allocate, but the two conversions in the other two functions do allocate." />
      <item value="A byte-slice-to-string conversion appearing as the index key of a map element retrieval expression doesn't allocate" />
      <item value="bytes-2-string-as-map-retrieval-key" />
      <item value="The performance differences between the two functions might be removed since a future Go toolchain version." />
      <item value="verbose" />
      <item value="Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other." />
      <item value="This optimization leads to the `verbose` function is more efficient than the `clean` function shown in the following code (as of the official standard Go compiler v1.17):" />
      <item value="The following is the implementation of the `Equal` function in the `bytes` standard package. In the implementation, the two conversions both don't duplicate the byte elements of the corresponding arguments." />
      <item value="A byte-slice-to-string conversion appearing as a comparison operand doesn't allocate" />
      <item value="neglectable" />
      <item value="If we use the official standard Go compiler to build the following code, the performance difference between the function `f` and the function `g` is neglectable. The reason is the `[]byte(s)` conversion used in the function `f` doesn't make allocations." />
      <item value="A string-to-byte-slice conversion following the `range` keyword doesn't allocate" />
      <item value="In fact, for some situations, the duplications are not necessary. The current standard Go compiler makes several special optimizations to avoid duplications for some simple cases. Such optimizations will be listed below." />
      <item value="the byte slice content (the byte elements of he the slice) will be duplicated and stored into the result string too (one memory allocation is needed)" />
      <item value="Similarly, for the same reason, when converting a byte slice to string" />
      <item value="This means that the string content (the bytes) will be duplicated and stored into the result byte slice (one memory allocation is needed)." />
      <item value="guarentee" />
      <item value="To make the guarentee (the bytes stored in a string will never be modified), when converting a string to byte slice, the string and the result byte slice should not share byte elements." />
      <item value="stored" />
      <item value="guarantee" />
      <item value="element-immutable" />
      <item value="Strings could be viewed as element-immutable byte slices. With the guarantee that the content of (a.k.a. the bytes stored in) a string will never be modified, any function can safely use the content of the string without worrying about the content of the string being modified elsewhere." />
      <item value="Conversions between strings and byte slices" />
      <item value="Conversions" />
      <item value="Metadata is our way of representing request headers internally. They're used at the RPC level and translate back and forth from Transport headers." />
      <item value="WithValue returns a copy of parent in which the value associated with key is val. Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface." />
      <item value="retrieve Worker" />
      <item value="PoolWithFunc accept the tasks from client,it limits the total of goroutines to a given number by recycling goroutines." />
      <item value="client credentials" />
      <item value="prepare Request Feature Map" />
      <item value="The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself: slice = append(slice, elem1, elem2) slice = append(slice, anotherSlice...) As a special case, it is legal to append a string to a byte slice, like this:" />
      <item value="DualStack previously enabled RFC 6555 Fast Fallback support, also known as &quot;Happy Eyeballs&quot;, in which IPv4 is tried soon if IPv6 appears to be misconfigured and hanging. Deprecated: Fast Fallback is enabled by default. To disable, set FallbackDelay to a negative value." />
      <item value="duplicate" />
      <item value="duplicated" />
      <item value="Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Package cobra is a commander providing a simple interface to create powerful modern CLI interfaces. In addition to providing an interface, Cobra simultaneously provides a controller to organize your application code." />
      <item value="记录" />
      <item value="延时" />
      <item value="延时记录" />
      <item value="Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2³¹-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use." />
      <item value="Intn returns, as an int, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n &lt;= 0." />
      <item value="Credible" />
      <item value="Audit" />
      <item value="Adds support for EditorConfig files. Define code style settings using EditorConfig files Use coding assistance in EditorConfig files To create an EditorConfig file in a directory, right-click this directory and select New | EditorConfig File. Originally developed by Kirill Glazyrin and Kevin Bell." />
      <item value="Shows errors reported by TSLint in the editor Provides a quick fix (Alt-Enter) and an action (&quot;Fix TSLint Problems&quot;) to fix errors and warnings using TSLint Imports matching code style rules defined in the TSLint configuration to the IDE code style settings" />
      <item value="The following forms are permitted: -flag -flag=x -flag x non-boolean flags only One or two minus signs may be used; they are equivalent. The last form is not permitted for boolean flags because the meaning of the command cmd -x where is a Unix shell wildcard, will change if there is a file called 0, false, etc. You must use the -flag=false form to turn off a boolean flag. Flag parsing stops just before the first non-flag argument (&quot;-&quot; is a non-flag argument) or after the terminator &quot;--&quot;. Integer flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may be: 1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False Duration flags accept any input valid for time.ParseDuration. The default set of command-line flags is controlled by top-level functions. The FlagSet type allows one to define independent sets of flags, such as to implement subcommands in a command-line interface. The methods of FlagSet are analogous to the top-level functions for the command-line flag set." />
      <item value="Define flags using flag.String(), Bool(), Int(), etc. This declares an integer flag, -n, stored in the pointer nFlag, with type int: import &quot;flag&quot; var nFlag = flag.Int(&quot;n&quot;, 1234, &quot;help message for flag n&quot;) If you like, you can bind the flag to a variable using the Var() functions. var flagvar int func init() { flag.IntVar(&amp;flagvar, &quot;flagname&quot;, 1234, &quot;help message for flagname&quot;) } Or you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by flag.Var(&amp;flagVal, &quot;name&quot;, &quot;help message for flagname&quot;) For such flags, the default value is just the initial value of the variable. After all flags are defined, call flag.Parse() to parse the command line into the defined flags. Flags may then be used directly. If you're using the flags themselves, they are all pointers; if you bind to variables, they're values. fmt.Println(&quot;ip has value &quot;, ip) fmt.Println(&quot;flagvar has value &quot;, flagvar) After parsing, the arguments following the flags are available as the slice flag.Args() or individually as flag.Arg(i). The arguments are indexed from 0 through flag.NArg()-1. Command line flag syntax" />
      <item value="SIGABRT" />
      <item value="sigNoteSetup initializes an async-signal-safe note. The current implementation of notes on Darwin is not async-signal-safe, because the functions pthread_mutex_lock, pthread_cond_signal, and pthread_mutex_unlock, called by semawakeup, are not async-signal-safe. There is only one case where we need to wake up a note from a signal handler: the sigsend function. The signal handler code does not require all the features of notes: it does not need to do a timed wait. This is a separate implementation of notes, based on a pipe, that does not support timed waits but is async-signal-safe." />
      <item value="Key Up Gread" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="128" />
        <entry key="ENGLISH" value="129" />
        <entry key="AFRIKAANS" value="1" />
        <entry key="FILIPINO" value="1" />
        <entry key="HAITIAN_CREOLE" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="HUNGARIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1640013756437" />
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
  </component>
</application>