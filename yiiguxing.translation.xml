<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="424" />
    <option name="newTranslationDialogY" value="345" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Instance" />
      <item value="Mechanical domain." />
      <item value="Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC You may customize this to set a different epoch for your application." />
      <item value="A heap is a common way to implement a priority queue. To build a priority queue, implement the Heap interface with the (negative) priority as the ordering for the Less method, so Push adds items while Pop removes the highest-priority item from the queue. The Examples include such an implementation; the file example_pq_test.go has the complete source." />
      <item value="A Ring is an element of a circular list, or ring. Rings do not have a beginning or end; a pointer to any ring element serves as reference to the entire ring. Empty rings are represented as nil Ring pointers. The zero value for a Ring is a one-element ring with a nil Value." />
      <item value="TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter)." />
      <item value="Background returns a non-nil, empty Context. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests." />
      <item value="specific" />
      <item value="Bulk is the entry point to mass insertupdatedelete documents." />
      <item value="abnormal" />
      <item value="Subscribe" />
      <item value="retrieve" />
      <item value="finash" />
      <item value="批量" />
      <item value="bench" />
      <item value="benchmark" />
      <item value="Parent" />
      <item value="As `NaN` values are not equal to each other, it is always a vain to loop up an entry from a map by using a `NaN` key, which could be proved from the following code." />
      <item value="Every two `+Inf` (or `-Inf`) values are equal to each other, but every two `NaN` values are not equal." />
      <item value="In floating-point computations, there are some cases in which the computation results might be infinities (Inf) or not-a-number (NaN). For example, in the following code, a `+Inf` and a `NaN` values are produced (yes, an `Inf` value times zero results a `NaN` value)." />
      <item value="`NaN != NaN`, `Inf == Inf`" />
      <item value="But please note that, as shown in a previous section, if a struct type contains a `_` field of an incomparable type, then the struct type is also incomparable." />
      <item value="For example, the following program prints `true`." />
      <item value="The `_` fields in struct comparisons are ignored" />
      <item value="Struct values are compared field by field Similarly, when comparing two struct values, their fields will be compared one by one. Once two corresponding fields are found unequal, the whole comparison stops and a false result is resulted. The whole comparison might also stop for a panic produced in comparing two interfaces. For example, the first comparison in the following code results false, but the second one causes a panic." />
      <item value="For example, the first comparison in the following code results false, but the second one causes a panic." />
      <item value="When comparing two array values, their elements will be compared one by one. Once two corresponding elements are found unequal, the whole comparison stops and a false result is resulted. The whole comparison might also stop for a panic produced when comparing two interfaces." />
      <item value="Array values are compared element by element" />
      <item value="Please try to [avoid putting a zero-size field as the final field of a struct type](1-syntax-and-sanmatics.mdfinal-zero-size-field)." />
      <item value="Lest the `_` fields waste memory, their types should be zero-size types. For example, the size of the type `Ty` is smaller than the type `Tx` in the following code." />
      <item value="It is easy, just put an incomparable field in the struct type. For example, the following struct types are all incomparable." />
      <item value="How to make a struct type incomparable" />
      <item value="For example, the following program prints three `false`, then panics." />
      <item value="Comparing two interface values produces a panic if the dynamic type of the two operands are identical and the identical type is an incomparable type" />
      <item value="Go 1.18 introduces custom generics, so there might be a `slices.Compare` function in future Go versions to compare slices with any comparable element types." />
      <item value="The two ways have no requirements on the lengths of the two operand byte slices." />
      <item value="The second way: `string(x) == string(y)`. Due to an optimization made by the official standard Go compiler, no underlying bytes will be duplicated in this way. In fact, the `bytes.Equal` function uses this way to do the comparison." />
      <item value="The first way: `bytes.Compare(x, y) == 0`." />
      <item value="FormatInt returns the string representation of i in the given base, for 2 &lt;= base &lt;= 36. The result uses the lower-case letters 'a' to 'z' for digit values &gt;= 10." />
      <item value="The above introduced way works for slices with any comparable element types. It certainly could be used to compare byte slices (which lengths are equal and known at coding time). Meanwhile, there are two other ways to compare byte slices `x` and `y`, even if the lengths of the two byte slices are not known at compile time." />
      <item value="More ways to compare byte slices" />
      <item value="The two lines compile okay." />
      <item value="The following two lines fail to compile." />
      <item value="In Go, slices are incomparable. But if the elements of two slices are comparable, then there is a way to compare the two slices (since Go version 1.17). Assume the elements of the two slices are identical and their lengths are equal and known at coding time, then we could use the following way to compare the two slices." />
      <item value="Compare two slices which lengths are equal and known at coding time" />
      <item value="Comparisons Related" />
      <item value="SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order." />
      <item value="Package builder is a lightweight and fast SQL builder for Go and XORM. Make sure you have installed Go 1.8+ and then:" />
      <item value="Structs contains various utilities to work with Go (Golang) structs. It was initially used by me to convert a struct into a `map[string]interface{}`. With time I've added other utilities for structs. It's basically a high level package based on primitives from the reflect package. Feel free to add new functions or improve the existing code." />
      <item value="float32 &amp; float64 may be not inexact as conditions" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="175" />
        <entry key="ENGLISH" value="176" />
        <entry key="ALBANIAN" value="1" />
        <entry key="AFRIKAANS" value="1" />
        <entry key="FILIPINO" value="1" />
        <entry key="HAITIAN_CREOLE" value="2" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="SCOTS_GAELIC" value="1" />
        <entry key="HUNGARIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1642557910982" />
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
  </component>
</application>